// This file is part of CiAO/IP.
//
// CiAO/IP is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// CiAO/IP is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with CiAO/IP.  If not, see <http://www.gnu.org/licenses/>.
//
// Copyright (C) 2011 Christoph Borchert, 2012 David GrÃ¤ff

#pragma once
/**
 * Purspose: 
 */
#include "util/types.h"
#include "router/Interface.h"
#include "ipstack/SendBuffer.h"
#include "stdio.h"

using namespace ipstack;
/**
 * Purpose:
 * Sending functionality for a socket. In a dual stack configuration the IP version is set
 * by the last call to ipX.set_dest_addr(..).
 * 
 * Performance: Because a dual-stack requires a runtime check on generic methods there is
 * a performance penality. By using this wrapper on a single-stack, there is no additional
 * overhead. By using it on a dual-stack there are at most two additional compares,
 * one in send() and one in requestSendBuffer() if you use IPv6 (because IPv4 is tried first).
 * 
 */
slice class Socket_Send_Slice {

public:
	/**
	 * You have to request a send-buffer to send data via send(...) in sockets.
	 * @arg requestSize The maximum size in bytes you want to use for your data.
	 * 
	 * Write your payload either to the data address like in this example:
	 * Socket s;
	 * SendBuffer* b = s.requestSendBuffer(size);
	 * if (!b) ABORT();
	 * memcpy(b->data, "test", 4); OR (UInt32)*b->data = 47248459;
	 * b->writtenToDataPointer(UInt16 length)
	 * s.send(b);
	 * 
	 * or use the write(const char* data, UInt16 length) method.
	 * 
	 * Always check if you got a null pointer as a result. This indicates your
	 * requested size is to big or there is no memory chunk of this size
	 * available at the moment. Wait and try it later.
	 * 
	 * A SendBuffer object is invalid after calling send with it. You have to
	 * request a new one for more data to send!
	 * 
	 * Always free a SendBuffer after using it. Call SendBuffer::free(b);
	 * 
	 */
	SendBuffer* requestSendBuffer(UInt16Opt requestSize) {
		SendBuffer* b = SendBuffer::createSendBuffer(mempool, estimateSendBufferMinSize()+requestSize);
		if (!b) return 0;
		prepareSendBuffer(b);
		return b;
	}
	
	Interface* getUsedInterface() {
		return 0;
	}
	
	/**
	 * Influenced by aspects of all network-stack layers to get the mimimum
	 * size for a send buffer to contain all those headers. The current state
	 * of the layers should be taken into consideration. E.g. IPv6 should
	 * increase the size by its own header and all IPv6 extension headers it
	 * plan to add at its current state.
	 */
	unsigned estimateSendBufferMinSize() {
		return 0;
	}
	
	/**
	 * Influenced by aspects of all network-stack layers to add their own headers.
	 * The current state of the layers should be taken into consideration. E.g. IPv6 should
	 * add its own header and IPv6 extension headers depending on its current state.
	 */
	void prepareSendBuffer(SendBuffer* sendbuffer) {}
	
	/**
	 * Send the data of a SendBuffer that was created with requestSendBuffer().
	 * 
	 * Although a SendBuffer stays valid after sending it, you can only use it for sending
	 * the same packet again. write(...) etc will not work, because the sendbuffer is
	 * filled and can not be reseted.
	 * Internal details: The memory block of a sendbuffer is read out by DMA from the
	 * network device. You cannot change that memory block after calling send() for this reason.
	 * 
	 */
	void send(SendBuffer* dataToSend) {
		Interface* i = getUsedInterface();
		if (!i) return;
		send(dataToSend, i);
	}
	void send(SendBuffer* dataToSend, Interface* i) {
		i->send(dataToSend->getDataStart(), dataToSend->getSize());
		//dataToSend->makeInvalid();
	}
	
	/**
	 * Free a Sendbuffer by using this static method. This will block
	 * until the memory block has been transfered if there is still
	 * a transfer ongoing.
	 */
	void free(SendBuffer* b) {
		Interface* i = getUsedInterface();
		if (!i) return;
		while (!i->hasBeenSent(b->getDataStart())) {}
		Mempool* mempoolL = b->m_mempool;
		mempoolL->free((void*)b);
	}
	
	UInt16Opt getMTU() {
		Interface* i = getUsedInterface();
		if (!i) return 0;
		return i->getMTU();
	}
	
	/**
	 * The minium of the remaining MTU and the available memory.
	 * Use this before creating a UDP SendBuffer for example.
	 */
	UInt16Opt getMaxPayloadLength() {
		const UInt16Opt headersize = getUsedInterface() ? estimateSendBufferMinSize() : 0;
		const UInt16Opt memsize = mempool->getMaxFreeBlockSize();
		const UInt16Opt mtusize = getMTU();
		if (memsize<mtusize) return memsize-headersize;
		return mtusize-headersize;
	}
	
	/**
	 * Return true if src and dest address are set up in the
	 * used ip version.
	 */
	bool hasValidSrcDestAddresses() {return false;}
};
