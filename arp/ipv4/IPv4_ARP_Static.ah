#ifndef __IPV4_ARP_STATIC_AH__
#define __IPV4_ARP_STATIC_AH__

#include "../../router/Interface.h"
#include "../ARP_Cache.h"
#include "ARP_Cache_IPv4_Static_Slice.ah"

using namespace ipstack;


aspect IPv4_ARP_Static {
  // *** Affect class: ARP_Cache
  advice "ipstack::ARP_Cache" : slice ARP_Cache_IPv4_Static_Slice;
  
  //prefer static ARP_Cache 
  advice execution("% ipstack::ARP_Cache::ipv4_lookup(%, ipstack::Interface*)") :
         order("IPv4_ARP_Static", "IPv4_ARP_Send");
  
  advice execution("% ipstack::ARP_Cache::ipv4_lookup(%, ipstack::Interface*)") &&
         args(ipv4_addr, interface) &&
         that(cache) :
         around(UInt32 ipv4_addr, Interface* interface, ARP_Cache& cache) {

    for(unsigned i=0; i<ARP_Cache::MAX_STATIC_ENTRIES; i++){      
      ARP_Cache::static_entry& entry = cache.static_entries[i];
      if(entry.ipv4_addr == ipv4_addr){
        *tjp->result() = entry.hw_addr;
        return;
      }
    }
    tjp->proceed();
  }

};
#endif // __IPV4_ARP_STATIC_AH__
