// This file is part of Aspect-Oriented-IP.
//
// Aspect-Oriented-IP is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Aspect-Oriented-IP is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Aspect-Oriented-IP.  If not, see <http://www.gnu.org/licenses/>.
//
// Copyright (C) 2012-2013 David GrÃ¤ff

#pragma once

#include "util/ipstack_inttypes.h"
#include "icmpv6/ICMPv6_Packet.h"
#include "icmpv6/ndp/NDPNeighborMessages.h"
#include "icmpv6/ICMPv6_Socket.h"
#include "ipv6/IPv6_Packet.h"
#include "ipv6/ndpcache/NDPCacheEntry.h"
#include "ipv6/AddressMemory.h"
#include "ipv6/IPv6.h"
#include "router/Interface.h"
#include "demux/Demux.h"

aspect NDP_Address_Duplication {

	/**
	  * Check for a duplicate address. If the interface has assigned a duplicate, we have to change the address
	  * and redo the procedure. This implementation only changes one byte: If all 255 available addresses are
	  * duplicates the interface will be unusable. If a device with the same logic and the same start address is within the local network
	  * both devices will never get a usuable interface.
	  */
	static bool is_duplicate_address(const ipstack::ipv6addr& ipv6_dstaddr, Interface* interface) {
		// duplicate address detection
		uint8_t nextEntry = 0;
		InterfaceAddressesIPv6& ipv6Addr = interface->ipv6;
		while (AddressEntryIPv6* AddressEntryIPv6 = ipv6Addr.getAddress(&nextEntry)) {
			if (/*AddressEntryIPv6->state == AddressEntryIPv6::AddressEntryIPv6StateTemporary &&*/ // Would be nice, but we have no timer -> all addresses are valid until proofed wrong currently
				compare_ipv6_addr(ipv6_dstaddr, AddressEntryIPv6->ipv6)) {
				// Oh no! We have created a duplicate address. "Remove" it from our interface.
				ipv6Addr.freeAddress(AddressEntryIPv6);
				// And add it with a changed byte: Hopefully this will not be a duplicate. We will check that of couse.
				ipstack::ipv6addr next_ip_address;
				copy_ipv6_addr(next_ip_address, ipv6_dstaddr)) {
				++(next_ip_address[15]);
				// This will cause a duplicate address detection
				ipv6Addr.addAddress(next_ip_address, AddressEntryIPv6::AddressEntryIPv6StateTemporary);
				return true;
			}
		}
		return false;
	}
	
	/**
	 * Address duplicate detection. After assigning an IP to an interface with the temporary state,
	 * do an address duplicate detection: Send out a Neighbor solicitation message with the unspecified ip (::)
	 * as src to the soliciated multicast address of our assigned ip. Use the assigned ip as "target_address" 
	 * parameter in the neighbor_solicitation message. If we get a Neighbor advertisement response, the address is in use already and we have
	 * to select another ip.
	 */
	advice execution("% ipstack::Interface::setIPv6AddressState(...)") && args(entry, ipstate) && that(interface) :
		before(AddressEntryIPv6* entry, uint8_t ipstate, Interface& interface) {

		if (ipstate == AddressEntryIPv6::AddressEntryIPv6StateTemporary) {
			ipstack::ipv6addr srcaddr = {{0}};
			NDPNeighborMessages::send_neighbor_solicitation(srcaddr, entry->ipv6, &interface, true);
		}
	}
	
	advice execution("void ipstack::Demux::ndp_neighbor_advertisement_demux(ipstack::IPv6_Packet*, ipstack::NDPNeighborMessages::NeighborAdvertisementMessage*, unsigned, ipstack::Interface*)") &&
	args(packet, message, payloadlen, interface) && that(demux) :
		around(IPv6_Packet* packet, NDPNeighborMessages::NeighborAdvertisementMessage* message, unsigned payloadlen, Interface* interface, Demux& demux) {

			if (!message->isResponse()) {
				tjp->proceed();
				return;
			}

			// If we requested an advertisment we are in the process of duplicate-address-detection.
			// We do check our interface addresses now and change addresses if necessary
			is_duplicate_address(message->target_address, interface);

			tjp->proceed();
	}
};
