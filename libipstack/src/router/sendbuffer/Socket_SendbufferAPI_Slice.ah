// This file is part of Aspect-Oriented-IP.
//
// Aspect-Oriented-IP is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Aspect-Oriented-IP is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Aspect-Oriented-IP.  If not, see <http://www.gnu.org/licenses/>.
//
// Copyright (C) 2011 Christoph Borchert, 2012 David GrÃ¤ff

#pragma once
/**
 * Purspose: 
 */
#include "util/ipstack_inttypes.h"
#include "router/Interface.h"
#include "router/sendbuffer/SendBuffer.h"

using namespace ipstack;
/**
 * Purpose:
 * Sending functionality for a socket. In a dual stack configuration the IP version is set
 * by the last call to ipX.set_dest_addr(..).
 * 
 * Performance: Because a dual-stack requires a runtime check on some methods there is
 * a performance penality. By using this wrapper on a single-stack, there is no additional
 * overhead. By using it on a dual-stack there are at most two additional compares,
 * one in send() and one in requestSendBuffer() if you use IPv6 (because IPv4 is tried first).
 * 
 */
slice class Socket_SendbufferAPI_Slice {

public:
	SendBuffer* requestSendBuffer(uint_fast16_t requestSize, ReceiveBuffer* use_as_response = 0) {
		return requestSendBuffer(getUsedInterface(), requestSize, use_as_response);
	}
	SendBuffer* requestSendBuffer(Interface* interface, uint_fast16_t requestSize, ReceiveBuffer* use_as_response = 0)
	{
		SendBuffer* sendbuffer = SendBuffer::createInstance(get_Mempool(), estimateSendBufferMinSize() + requestSize, interface);
		if (!sendbuffer) return 0;
		prepareSendBuffer(sendbuffer,use_as_response);
		if (sendbuffer->getState()!=SendBuffer::WritingState) {
			return 0;
		}
		return sendbuffer;
	}

	Interface* getUsedInterface() {
		return 0;
	}
	
	/**
	 * Influenced by aspects of all network-stack layers to get the mimimum
	 * size for a send buffer to contain all those headers. The current state
	 * of the layers should be taken into consideration. E.g. IPv6 should
	 * increase the size by its own header and all IPv6 extension headers it
	 * plan to add at its current state.
	 */
	unsigned estimateSendBufferMinSize() {
		return 0;
	}
	
	/**
	 * Influenced by aspects of all network-stack layers to add their own headers.
	 * The current state of the layers should be taken into consideration. E.g. IPv6 should
	 * add its own header + IPv6 extension headers depending on its current state.
	 */
	void prepareSendBuffer(SendBuffer* sendbuffer, ReceiveBuffer* use_as_response) {}
	
	/**
	 * Send the data of a SendBuffer that was created with requestSendBuffer(). The packet is
	 * invalid after sending it and may be freed by calling socket->freeSendbuffer(sendbuffer).
	 */
	bool send(SendBuffer* dataToSend) {
		if (dataToSend->getState()!=SendBuffer::WritingState) { // it is not supported to send a sendbuffer again.
			return false;
		}
		dataToSend->setState(SendBuffer::TransmittedState);
		dataToSend->getInterface()->send(dataToSend->getDataStart(), dataToSend->getSize());
		return true;
	}
	
	/**
	 * A convenience method to get the maximum transmission unit for the used interface.
	 */
	uint_fast16_t getMTU(Interface* interface = 0) const {
		if (interface==0)
			interface = getUsedInterface();
		if (!interface)
			return 0;
		return interface->getMTU();
	}
	
	/**
	 * The minium of the remaining MTU and the available memory.
	 * Use this before creating a UDP SendBuffer where you want a maximum of available space for example.
	 */
	uint_fast16_t getMaxPayloadLength(Interface* interface = 0) const {
		if (interface==0)
			interface = getUsedInterface();
		const uint_fast16_t headersize = interface ? estimateSendBufferMinSize() : 0;
		const uint_fast16_t memsize = get_Mempool()->getMaxFreeBlockSize();
		const uint_fast16_t mtusize = getMTU(interface);
			
		if (memsize<mtusize) return memsize-headersize;
		return mtusize-headersize;
	}
	
	/**
	 * Return true if src and dest address are set up in the
	 * used ip version.
	 */
	bool hasValidSrcDestAddresses() const {return false;}
};
