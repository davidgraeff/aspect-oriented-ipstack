// This file is part of Aspect-Oriented-IP.
//
// Aspect-Oriented-IP is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Aspect-Oriented-IP is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Aspect-Oriented-IP.  If not, see <http://www.gnu.org/licenses/>.
//
// Copyright (C) 2012-2013 David GrÃ¤ff

#pragma once

#include "demux/Demux.h"
#include "sending/SendBuffer.h"

using namespace ipstack;

/**
 * An incoming packet may trigger the generation of multiple response messages.
 * For example an incoming "neighbor solicitation message" (icmpv6) have to be answered by an
 * "neighbor advertisement message" and additionally if the remote host is unknown we have
 * to send a "neighbor solicitation message" on our own. For the case that the network device has
 * a shared buffer for incoming/outgoing traffic and because we generally do not copy the incoming
 * packet to a buffer of our own it is recommend to activate this option to delay sending
 * packets until the received packet has been processed entirely.
 * 
 * 
 */
aspect delay_send  {
	advice "ipstack::Demux" : slice class {
	public:
		int mHoldBack;
		SendBuffer* first_delayed_sendbuffer;
	};
	
	advice construction("ipstack::Demux") : after() {
		mHoldBack = 0;
		first_delayed_sendbuffer = 0;
	}
	
	// advice ordering: always execute this aspect first
	advice execution("% ipstack::%_Socket::send(ipstack::SendBuffer*)") : 
	order( "delay_send%","%" && !"delay_send%" );
	
	/**
	  * We intercept send requests and if mHoldBack is active we just do nothing. The affected sendbuffers will
	  * be send at the end of the "ipv6_payload_demux"-advice of this aspect.
	  */
	advice execution("% ipstack::%_Socket::send(ipstack::SendBuffer*)") && args(dataToSend) : around(SendBuffer* dataToSend){
		if (!dataToSend->mDirectResponse) {
			tjp->proceed();
			return;
		}
		
		Demux& demux = Demux::Inst();
		if (demux.mHoldBack) {
			dataToSend->setState(SendBuffer::AboutToBeTransmittedState);
			if (demux.first_delayed_sendbuffer) {
				dataToSend->next_delayed_sendbuffer = demux.first_delayed_sendbuffer;
			}
			demux.first_delayed_sendbuffer = dataToSend;
			*tjp->result() = false;
			return;
		}
		
		tjp->proceed();
	}
	

	
	// After output aspect buf before all other aspects
	advice execution("% ipstack::Demux::demux(...)") : 
	order( "IPv6_ICMP_Receive_Output", "delay_send%","%" && !"delay_send%" && !"IPv6_ICMP_Receive_Output%" );
	
	advice execution("% ipstack::Demux::demux(...)") : around() {
		Demux& demux = Demux::Inst();
		int& holdback = demux.mHoldBack;
		++holdback;
		
		tjp->proceed();
		
		--holdback;
		
		// We only send out data if holdBack == 0 (reantrance is possible)
		if (holdback>0)
			return;
		
		/**
		 * Initiate the sending for all SendBuffer objects that haven't been send so far.
		 */
		Sendbuffer* next = demux.first_delayed_sendbuffer;
		while (next) {
			next->setState(SendBuffer::TransmittedState);
			next->getInterface()->send(next->getDataStart(), next->getSize());
			next = next.next_delayed_sendbuffer);
		}
		demux.first_delayed_sendbuffer = 0;
	}
};
