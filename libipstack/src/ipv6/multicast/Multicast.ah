// This file is part of Aspect-Oriented-IP.
//
// Aspect-Oriented-IP is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Aspect-Oriented-IP is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Aspect-Oriented-IP.  If not, see <http://www.gnu.org/licenses/>.
//
// Copyright (C) 2012 David GrÃ¤ff

#pragma once

#include "router/Interface.h"
#include "router/Router.h"
#include "router/sendbuffer/SendBuffer.h"
#include "ipv6/IPv6.h"

// #include "ipv6/IPv6_Packet.h"
// #include "util/ipstack_inttypes.h"

using namespace ipstack;

/**
 * Allow Multicast addresses to be set as destination address. This is neccessary for some
 * ICMPv6 traffic. If this aspect is not configured, setting a multicast address as destination will
 * only work if a static IP Prefix entry with the prefix of the multicast-scope has been added.
 */
aspect IPv6_Multicast_aspect {
	/**
	 * If the destination address is a multicast address, just pick the first active ipv6 interface
	 * for sending. In the send advice will will send this packet to all interfaces respectively.
	 */
	advice execution("% ipstack::Router::ipv6_find_route(...)") && args(ipv6_dstaddr) && that(router) :
		around(const ipv6addr& ipv6_dstaddr, Router& router) {
		//search for local interface. check assigned ip addresses
		bool isMulticast = (IPV6AddressScope::getIPv6AddressScope(ipv6_dstaddr) == IPV6AddressScope::IPV6_SCOPE_MULTICAST);
		if (!isMulticast) {
			tjp->proceed();
			return;
		}
		Interface* interface = router.head_interface;
		while (interface != 0) {
			if (interface->isIPv6Up()) {
				// Pick the first active interface
				*(tjp->result()) = RouteResult(0,interface);
				return;
			}
			interface = interface->getNext();
		}
		*(tjp->result()) = RouteResult(0,0);
	}

	/**
	 * Send a multicast packet to all interfaces, not just the first one
	 */
	advice execution("% ipstack::SendBuffer::send()" && that(dataToSend) : before(SendBuffer& dataToSend) {
		// only if send worked
// 		if (!worked)
// 			return;
		
		// only for IPv6
		IPv6_Packet* ip_packet = (IPv6_Packet*) dataToSend.p.ip_packet;
		if (IP::get_ip_version(ip_packet) != 6) {
			return;
		}

		// only for a multicast address
		bool isMulticast = (IPV6AddressScope::getIPv6AddressScope(ip_packet->get_dst_addr()) == IPV6AddressScope::IPV6_SCOPE_MULTICAST);
		if (!isMulticast) {
			return;
		}

		Interface* interface = Router::Inst().get_interface(0);
		Interface* alreadySendOnInterface = dataToSend.getInterface();
		while (interface != 0) {
			// send on all but the original interface
			if (interface != alreadySendOnInterface && interface->isIPv6Up()) {
				// recycle sendbuffer
				dataToSend.recycle();
				dataToSend.setInterface(interface);
				// Do not use the SendBuffer::send method as that is matched by checksum
				// aspects and so on and our sendbuffer is perfectly valid already (we are
				// in %_Socket::send actually)
				interface->send(dataToSend.getDataStart(), dataToSend.getSize());
			}
			interface = interface->getNext();
		}
		// Restore first interface
		dataToSend.setInterface(alreadySendOnInterface);
	}

	/**
	 * Receive multicast traffic
	 */
	advice execution("bool ipstack::InterfaceAddressesIPv6::hasAddress(const ipstack::ipv6addr&)") && args(addr) && that(interface) :
		around(const ipstack::ipv6addr& addr, InterfaceAddressesIPv6& interface) {
		bool isMulticast = (IPV6AddressScope::getIPv6AddressScope(addr) == IPV6AddressScope::IPV6_SCOPE_MULTICAST);
		if (!isMulticast) {
			tjp->proceed();
			return;
		}
		Multicast_IPv6 m(&interface);
		// Check implicit multicast groups (solicitedNode_multicast)
		*(tjp->result()) = m.multicast_addr_joined(addr) || m.is_solicitedNode_multicast_addr(addr);
	}

	// Join multicast groups before assigning an ip
	advice execution("void ipstack::InterfaceAddressesIPv6::setUp(bool)") :
		order("IPv6_Multicast_aspect", "IPv6_add_link_local_address");

	/**
	 * Join/leave all-nodes and all-routers multicast group on interface up/down
	 */
	advice execution("void ipstack::InterfaceAddressesIPv6::setUp(bool)") && args(up) && that(interface) : around(bool up, InterfaceAddressesIPv6& interface) {
		Multicast_IPv6 m(&interface);
		if (up) {
			m.join_linkLocal_allRouters_multicastGroup();
			m.join_linkLocal_allNodes_multicastGroup();
		} else {
			m.leave_linkLocal_allRouters_multicastGroup();
			m.leave_linkLocal_allNodes_multicastGroup();
		}
		tjp->proceed();
	}
	
	/**
	 * The Multicast Listener Discovery Version 2 Protocol have to indicate our interest to routers in receiving
	 * packets that are related to Neighbor Discovery Protocol responses. Therefore the multicast aspect have to act
	 * before NDP aspects.
	 */
	advice execution("ipstack::AddressEntryIPv6* ipstack::InterfaceAddressesIPv6::addAddress(...)") :
	order("IPv6_Multicast_aspect", "%NDP%");
	
	/**
	 * Join solicitated node multicast group for every unicast address that is assigned to an interface
	 */
	advice execution("void ipstack::InterfaceAddressesIPv6::addAddress(...)") && args(entry) && that(interface) : after(AddressEntryIPv6* entry, InterfaceAddressesIPv6& interface) {
		if (!entry || entry->state == AddressEntryIPv6::AddressEntryIPv6StateMulticast)
			return;
		
		ipv6addr ip = entry->ipv6;
		IPV6AddressScope::IPv6_ADDRESS_SCOPE scope = IPV6AddressScope::getIPv6AddressScope(ip);
		if (scope==IPV6AddressScope::IPV6_SCOPE_GLOBAL_UNICAST || scope==IPV6AddressScope::IPV6_SCOPE_UNIQUE_LOCAL_UNICAST 
			|| scope==IPV6AddressScope::IPV6_SCOPE_LINKLOCAL) {
			Multicast_IPv6 m(&interface);
			m.join_solicitedNode_multicastGroup(ip);
		}
	}
	
	/**
	 * Leave solicitated node multicast group for every unicast address that will be removed from an interface
	 */
	advice execution("% ipstack::InterfaceAddressesIPv6::freeEntry(...)") && args(entry) && that(interface) : before(AddressEntryIPv6* entry,InterfaceAddressesIPv6& interface) {
		if (entry->state == AddressEntryIPv6::AddressEntryIPv6StateMulticast)
			return;
		
		ipv6addr ip = entry->ipv6;
		IPV6AddressScope::IPv6_ADDRESS_SCOPE scope = IPV6AddressScope::getIPv6AddressScope(ip);

		if (scope==IPV6AddressScope::IPV6_SCOPE_GLOBAL_UNICAST || scope==IPV6AddressScope::IPV6_SCOPE_UNIQUE_LOCAL_UNICAST) {
			interface.leave_solicitedNode_multicastGroup(ip);
		}
	}
};
