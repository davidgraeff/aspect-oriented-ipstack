// This file is part of Aspect-Oriented-IP.
//
// Aspect-Oriented-IP is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Aspect-Oriented-IP is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Aspect-Oriented-IP.  If not, see <http://www.gnu.org/licenses/>.
//
// Copyright (C) 2012 David GrÃ¤ff

#pragma once
#include "ipv6/IPv6_Packet.h"
#include "ipv6/IPv6onSockets.h"
#include "../ICMPv6_Packet.h"
#include "../ICMPv6_Socket.h"
#include "MLDMessages.h"
#include "router/Interface.h"
#include "demux/Demux.h"
#include "router/sendbuffer/SendBuffer.h"
#include "util/ipstack_inttypes.h"

/**
 * Purpose: 
 * We respond immediately to a Multicast Query. RFC recommends to wait for a random time if multiple devices
 * start up at the same time after a power shortage etc.
 */
aspect NDP_MDL_Respond {
	advice execution("bool ipstack::ICMPv6_DerivedSocket::acceptedData(%,%)") &&
	args(type, code) : around(uint8_t type, uint8_t code) {
		if ((type == 130)) {
			tjp->result() = true;
			return;
		}
		tjp->proceed();
	}
	
	/**
	  * Respond to multicast Query (This is a version 1 response, but should work with version 2 implementations, too)
	  */

	advice execution("void ipstack::ICMPv6_DerivedSocket::receiveCallback(ipstack::SmartReceiveBufferPtr&)") &&
	args(b) : around(SmartReceiveBufferPtr& b) {

		ICMPv6_Packet* icmp_packet = static_cast<ICMPv6_Packet*>(b.get_payload_data());
		MLDMessages::mld_multicast_listener_query* query = (MLDMessages::mld_multicast_listener_query*)icmp_packet;
		if (query->type == 130) {
			bool need_response = false;

			if (!is_not_unspecified_ipv6_address(query->addr)) { // multicast_addr == ::
				// is a General Query
				need_response = true;
			} else {
				// is a Multicast Address Specific Query: Check each address if it is one ouf ours
				if (b.get_interface()->hasIPv6Address(query->addr)) {
					need_response = true;
				}
			}

			if (need_response) {
				ICMPv6_DerivedSocket& socket = Management_Task::Inst().get_socket_icmpv6();
				IPV6& ipv6 = socket.ipv6;
				ipv6.setHoplimit(1);
				
				const unsigned maxlen = sizeof(MLDMessages::mldv1_listener_report);
				SendBuffer* sbi = socket.requestSendBuffer(maxlen, b.receivebuffer_pointer());
				if (sbi) {
					sbi->mark("NDP_MDL_Respond");
					MLDMessages::write_mldv1_listener_report((char*)sbi->getDataPointer(), query->addr);
					sbi->writtenToDataPointer(sizeof(MLDMessages::mldv1_listener_report));
					socket.send(sbi);
				}
				ipv6.restoreDefaultSendingConfiguration(); // Reset hop limit etc
			}
		} else {
			tjp->proceed();
		}
	}
};
