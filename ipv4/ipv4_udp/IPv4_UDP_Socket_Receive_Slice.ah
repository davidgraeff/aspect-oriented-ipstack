#ifndef __IPV4_UDP_SOCKET_RECEIVE_SLICE__
#define __IPV4_UDP_SOCKET_RECEIVE_SLICE__

#include <string.h> //for memcpy

using namespace ipstack;

slice class IPv4_UDP_Socket_Receive_Slice {
  IPv4_UDP_Socket* next;
  
  friend class Demux; //allow Demux to use getNext(), setNext(...)
  IPv4_UDP_Socket* getNext() { return next; }
  void setNext(IPv4_UDP_Socket* sock) { next = sock; }
  
  bool put(IPv4_Packet* packet, unsigned len){
    if(IPv4_Socket::get_packetbuffer()->isFull() == false){
      void* clone = UDP_Socket::get_Mempool()->alloc(len);
      if(clone != 0){
        memcpy(clone, packet, len); //TODO: don't use memcpy?
        IPv4_Socket::get_packetbuffer()->put(clone);
        return true;
      }
    }
    return false;
  }

  public:
  IPv4_Packet* receive(){
    return IPv4_Socket::receive();
  }
  
  IPv4_Packet* read(){
    return IPv4_Socket::read(); //non-blocking
  }
  
  void free(IPv4_Packet* packet){
    UDP_Socket::get_Mempool()->free(packet);
  }
  
  // explicit join-points: affected by 'IPv4_UDP_Receive.ah' aspect.
  bool bind() { return false; } // register a new udp socket at Demux
  void unbind() {} // remove this udp socket at Demux
};

#endif // __IPV4_UDP_SOCKET_RECEIVE_SLICE__ 

