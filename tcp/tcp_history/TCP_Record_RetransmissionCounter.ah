#ifndef __TCP_RETRANSMISSION_COUNTER_AH__
#define __TCP_RETRANSMISSION_COUNTER_AH__

#include "TCP_History.h"
#include "TCP_Record.h"
#include "../TCP.h"
#include "../TCP_Socket.h"
#include "../TCP_Config.h"

#include "TCP_Record_RetransmissionCounter_Slice.ah"

using namespace ipstack;


aspect TCP_RetransmissionCounter { 
  
  // *** Affect class: TCP_Socket
  //this aspect must be executed after 'SlowStart', in order to count *REAL* retransmitted packets
  advice execution ("void ipstack::TCP_Socket::retransmit(ipstack::TCP_Record*, ipstack::TCP_Segment*)") : 
         order("%" && !"TCP_RetransmissionCounter", "TCP_RetransmissionCounter");
  
  advice execution("void ipstack::TCP_Socket::retransmit(ipstack::TCP_Record*, ipstack::TCP_Segment*)") &&
         args(record, segment) &&
         that(socket) :
         around(TCP_Record* record, TCP_Segment* segment, TCP_Socket& socket) {

    if(record->retransmission_counter > __TCP_MAX_RETRANSMISSIONS__) {
      /* DO NOT call abort() here, because the linked-list 'TCP_History'
         is under modification and will be corrupted. Wait for 'updateHistory()' to complete (see below).
         Just remember that we want to kill the connection (use state for storage) */
      socket.state = TCP_Socket::CLOSED;
    }
    else {
      record->retransmission_counter++;
      tjp->proceed(); // allow retransmit(...)
    }
  }
  
  advice execution("void ipstack::TCP_Socket::updateHistory()") &&
         that(socket) : after(TCP_Socket& socket) {
    //check if max. number of retransmissions was exceeded (see above)
    if(socket.state == TCP_Socket::CLOSED) {
      socket.abort(); //kill this connection
    }
  }
  
  
  // *** Affect class: TCP_Record
  advice "ipstack::TCP_Record" : slice TCP_Record_RetransmissionCounter_Slice;
  
  advice execution("void ipstack::TCP_Record::setSegment(ipstack::TCP_Segment*)") &&
         that(record) : after(TCP_Record& record) {
    record.retransmission_counter = 0; //init
  }
  
};

#endif //__TCP_RETRANSMISSION_COUNTER_AH__

